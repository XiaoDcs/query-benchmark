<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Page Scorer - Electron</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 15px;
      background-color: #f5f5f5;
      overflow-x: hidden;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      transition: background-color 0.3s ease;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .nav-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .score-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .action-buttons {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    button {
      padding: 8px 12px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #3367d6;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .score-button {
      padding: 10px 16px;
      font-weight: bold;
      font-size: 14px;
    }
    .pass {
      background-color: #34a853;
    }
    .pass:hover {
      background-color: #2e8b47;
    }
    .fail {
      background-color: #ea4335;
    }
    .fail:hover {
      background-color: #d33426;
    }
    .screenshot-top {
      background-color: #ff9800;
      padding: 8px 12px;
    }
    .screenshot-top:hover {
      background-color: #f57c00;
    }
    .content {
      display: flex;
      gap: 15px;
      height: calc(100vh - 100px); /* å‡å°‘é¡¶éƒ¨ç©ºé—´ï¼Œä»120pxæ”¹ä¸º100px */
      min-height: 650px;
    }
    .web-view {
      flex: 1;
      min-width: 500px;
      display: flex;
      flex-direction: column;
    }
    .web-frame {
      width: 100%;
      flex: 1;
      border: 1px solid #ddd;
      border-radius: 4px;
      height: 100%;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .sidebar {
      width: 320px;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 100%;
      overflow-y: auto;
    }
    .info-panel, .settings-panel, .issue-panel {
      background-color: #f9f9f9;
      padding: 12px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .progress-overview-panel {
      background-color: #f0f8ff;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #b3d9ff;
      flex-shrink: 0;
    }
    .progress-overview-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #1976d2;
    }
    .progress-stats {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 8px;
      background-color: #ffffff;
      border-radius: 4px;
      border: 1px solid #e1f5fe;
    }
    .stat-item {
      font-size: 11px;
      font-weight: bold;
      text-align: center;
    }
    .progress-grid {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      gap: 2px;
      margin-bottom: 10px;
      padding: 8px;
      background-color: #ffffff;
      border-radius: 4px;
      border: 1px solid #e1f5fe;
      max-height: 200px;
      overflow-y: auto;
    }
    .progress-item {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .progress-item:hover {
      transform: scale(1.2);
      z-index: 10;
    }
    .progress-item.pass {
      background-color: #4caf50;
    }
    .progress-item.fail {
      background-color: #f44336;
    }
    .progress-item.pending {
      background-color: #e0e0e0;
      border: 1px solid #bdbdbd;
    }
    .progress-item.current {
      background-color: #2196f3;
      box-shadow: 0 0 6px rgba(33, 150, 243, 0.6);
    }
    .progress-legend {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .legend-color {
      width: 8px;
      height: 8px;
      border-radius: 2px;
    }
    .legend-color.pass {
      background-color: #4caf50;
    }
    .legend-color.fail {
      background-color: #f44336;
    }
    .legend-color.pending {
      background-color: #e0e0e0;
      border: 1px solid #bdbdbd;
    }
    .legend-color.current {
      background-color: #2196f3;
    }
    .info-panel h3, .settings-panel h3, .issue-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .info-panel p {
      margin: 8px 0;
      font-size: 13px;
    }
    .status {
      margin-top: 10px;
      padding: 8px;
      background-color: #f2f2f2;
      border-radius: 4px;
      text-align: center;
      font-size: 12px;
      flex-shrink: 0;
    }
    .screenshot-preview {
      max-width: 100%;
      max-height: 120px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      font-size: 16px;
      color: #666;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: white;
      border-radius: 4px;
    }
    .hidden {
      display: none;
    }
    .url-display {
      word-break: break-all;
      color: #1a73e8;
      text-decoration: none;
      font-size: 12px;
    }
    .url-display:hover {
      text-decoration: underline;
    }
    .progress-bar {
      width: 100%;
      height: 4px;
      background-color: #e0e0e0;
      border-radius: 2px;
      margin: 8px 0;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background-color: #4285f4;
      transition: width 0.3s ease;
    }
    .web-container {
      position: relative;
      flex: 1;
    }
    
    /* ç´§å‡‘çš„ç¼©ç•¥å›¾å®¹å™¨ */
    #thumbnail-container {
      margin: 10px 0;
    }
    #thumbnail-container strong {
      font-size: 13px;
    }
    #thumbnail-preview, #thumbnail-placeholder {
      max-height: 80px;
      max-width: 100%;
      margin-top: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      display: block;
      cursor: pointer;
    }
    #thumbnail-placeholder {
      padding: 20px;
      background-color: #f5f5f5;
      text-align: center;
      color: #666;
      font-size: 12px;
    }
    
    /* è‡ªåŠ¨è·³è½¬å¼€å…³æ ·å¼ */
    .settings-panel {
      background-color: #f0f8ff;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #b3d9ff;
      flex-shrink: 0;
    }
    .settings-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #1976d2;
    }
    .toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 8px 0;
    }
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 24px;
      background-color: #ccc;
      border-radius: 12px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .toggle-switch.active {
      background-color: #4285f4;
    }
    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background-color: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .toggle-switch.active .toggle-slider {
      transform: translateX(26px);
    }
    .toggle-label {
      font-size: 13px;
      color: #333;
    }
    .preload-status {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
      padding: 6px;
      background-color: #f8f9fa;
      border-radius: 3px;
    }
    .shortcuts-info {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
      line-height: 1.4;
    }

    /* Issueæ ‡ç­¾ç›¸å…³æ ·å¼ */
    .issue-panel {
      background-color: #fff3e0;
      border: 1px solid #ffcc80;
    }
    .issue-panel h3 {
      color: #f57c00;
    }
    .preset-tags {
      margin-bottom: 10px;
    }
    .preset-tag {
      display: inline-block;
      background-color: #e3f2fd;
      color: #1976d2;
      padding: 4px 8px;
      margin: 2px 4px 2px 0;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
      border: 1px solid #bbdefb;
      transition: all 0.2s;
    }
    .preset-tag:hover {
      background-color: #bbdefb;
    }
    .preset-tag.active {
      background-color: #2196f3;
      color: white;
    }
    .preset-tag.custom-tag {
      background-color: #f3e5f5;
      color: #7b1fa2;
      border-color: #ce93d8;
    }
    .preset-tag.custom-tag:hover {
      background-color: #ce93d8;
    }
    .add-tag-btn {
      display: inline-block;
      background-color: #e8f5e8;
      color: #2e7d32;
      padding: 4px 8px;
      margin: 2px 4px 2px 0;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
      border: 1px dashed #4caf50;
      transition: all 0.2s;
    }
    .add-tag-btn:hover {
      background-color: #c8e6c9;
    }
    .add-tag-input {
      margin: 8px 0;
      padding: 8px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    .add-tag-input input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .add-tag-input button {
      padding: 4px 12px;
      margin-right: 4px;
      font-size: 11px;
    }
    .edit-tag-input {
      margin: 8px 0;
      padding: 8px;
      background-color: #fff3e0;
      border: 1px solid #ffcc80;
      border-radius: 4px;
    }
    .edit-tag-input input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .edit-tag-input button {
      padding: 4px 12px;
      margin-right: 4px;
      font-size: 11px;
    }
    .tag-shortcuts {
      font-size: 10px;
      color: #666;
      margin-top: 5px;
      line-height: 1.3;
    }
    
    /* ç§»åŠ¨ç«¯å“åº”å¼ */
    @media (max-width: 900px) {
      .content {
        flex-direction: column;
        height: auto;
        min-height: auto;
      }
      .sidebar {
        width: 100%;
        min-width: auto;
        max-height: none;
      }
      .web-view {
        min-width: auto;
        height: 50vh;
        min-height: 400px;
      }
      .controls {
        flex-direction: column;
        gap: 8px;
      }
      .nav-buttons, .score-buttons, .action-buttons {
        justify-content: center;
        flex-wrap: wrap;
      }
    }

    /* è‡ªå®šä¹‰å¿«æ·é”®é…ç½®æ ·å¼ */
    .shortcuts-config {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 12px;
      margin-top: 10px;
    }
    .shortcuts-config h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #495057;
    }
    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #e9ecef;
      font-size: 11px;
    }
    .shortcut-item:last-child {
      border-bottom: none;
    }
    .shortcut-label {
      color: #495057;
      flex: 1;
    }
    .shortcut-key {
      background-color: #e9ecef;
      border: 1px solid #ced4da;
      border-radius: 3px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      min-width: 60px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shortcut-key:hover {
      background-color: #dee2e6;
    }
    .shortcut-key.recording {
      background-color: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }
    .shortcut-key.conflict {
      background-color: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }
    .shortcuts-actions {
      margin-top: 10px;
      display: flex;
      gap: 5px;
    }
    .shortcuts-actions button {
      font-size: 10px;
      padding: 3px 8px;
    }
    .shortcut-help {
      font-size: 9px;
      color: #6c757d;
      margin-top: 5px;
      line-height: 1.3;
    }

    /* å®¹å™¨çŠ¶æ€èƒŒæ™¯è‰² */
    .container.status-unscored {
      background-color: white;
    }
    .container.status-pass {
      background-color: #e8f5e8;
    }
    .container.status-fail {
      background-color: #fde7e7;
    }

    /* å…¨å±å›¾ç‰‡æŸ¥çœ‹å™¨ */
    .fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2147483647; /* ä½¿ç”¨æœ€å¤§z-indexå€¼ç¡®ä¿åœ¨æ‰€æœ‰å†…å®¹ä¹‹ä¸Š */
      cursor: pointer;
    }
    .fullscreen-image {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
    }
    
    /* Issueè‡ªåŠ¨Failå¼€å…³æ ·å¼ */
    .auto-fail-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
      font-size: 12px;
    }
    .toggle-switch {
      position: relative;
      width: 40px;
      height: 20px;
      background-color: #ccc;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .toggle-switch.active {
      background-color: #4CAF50;
    }
    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background-color: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .toggle-switch.active .toggle-slider {
      transform: translateX(20px);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <div class="nav-buttons">
        <button id="file-btn">ğŸ“ Select Excel File</button>
        <button id="download-sample-btn">ğŸ“¥ Download Sample Excel</button>
        <button id="prev-btn" disabled>â† Previous</button>
        <button id="next-btn" disabled>Next â†’</button>
        <button id="reload-btn" disabled>ğŸ”„ Reload</button>
      </div>
      <div class="score-buttons">
        <button id="pass-btn" class="score-button pass" disabled>âœ… Pass (â†‘)</button>
        <button id="fail-btn" class="score-button fail" disabled>âŒ Fail (â†“)</button>
        <button id="screenshot-btn" class="screenshot-top" disabled>ğŸ“¸ Screenshot</button>
      </div>
      <div class="action-buttons">
        <button id="save-btn" disabled>ğŸ’¾ Save</button>
        <button id="open-external-btn" disabled>ğŸ”— Open in Browser</button>
      </div>
    </div>
    
    <div class="content">
      <div class="web-view">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
        <div class="web-container">
          <div id="web-frame" class="web-frame">
            <div style="text-align: center; color: #666; padding: 20px;">
              <div style="font-size: 48px; margin-bottom: 20px;">ğŸ“„</div>
              <div style="font-size: 18px; margin-bottom: 10px;">Please select an Excel file to start</div>
              <div style="font-size: 14px; color: #999;">Click "Select Excel File" button above</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="sidebar">
        <div class="info-panel">
          <h3>ğŸ“‹ Page Information</h3>
          <p><strong>Progress:</strong> <span id="page-counter">-</span></p>
          <p><strong>Query:</strong> <span id="current-query">-</span></p>
          <p><strong>URL:</strong> <a href="#" id="current-url" class="url-display" target="_blank">-</a></p>
          <p><strong>Current Score:</strong> <span id="current-score">Not scored</span></p>
          
          <div id="thumbnail-container">
            <strong>Thumbnail:</strong>
            <img id="thumbnail-preview" class="hidden" alt="Thumbnail" />
            <div id="thumbnail-placeholder">No thumbnail available</div>
          </div>
        </div>
        
        <div class="progress-overview-panel">
          <h3>ğŸ“Š Progress Overview</h3>
          <div class="progress-stats">
            <span class="stat-item">âœ… <span id="pass-count">0</span></span>
            <span class="stat-item">âŒ <span id="fail-count">0</span></span>
            <span class="stat-item">â¸ï¸ <span id="pending-count">0</span></span>
            <span class="stat-item">ğŸ“‹ <span id="total-count">0</span></span>
          </div>
          <div class="progress-grid" id="progress-grid">
            <!-- è¿›åº¦æ–¹å—å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
          </div>
          <div class="progress-legend">
            <span class="legend-item"><span class="legend-color pass"></span>Pass</span>
            <span class="legend-item"><span class="legend-color fail"></span>Fail</span>
            <span class="legend-item"><span class="legend-color pending"></span>Pending</span>
            <span class="legend-item"><span class="legend-color current"></span>Current</span>
          </div>
        </div>
        
        <div class="issue-panel">
          <h3>ğŸ“ Issue Notes</h3>
          
          <!-- é¢„è®¾æ ‡ç­¾åŒºåŸŸ -->
          <div class="preset-tags" id="preset-tags-container">
            <!-- æ ‡ç­¾å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            <span class="add-tag-btn" id="add-tag-btn" title="Add custom tag">+ Add Tag</span>
          </div>
          
          <div class="tag-shortcuts">
            <strong>Quick tags:</strong> Ctrl+1~9 for tags, Ctrl+0 to clear<br>
            <strong>Edit tags:</strong> Double-click to edit, right-click custom tags to delete
          </div>
          
          <!-- æ·»åŠ è‡ªå®šä¹‰æ ‡ç­¾çš„è¾“å…¥æ¡† -->
          <div class="add-tag-input hidden" id="add-tag-input">
            <input type="text" id="new-tag-input" placeholder="Enter new tag name..." maxlength="20">
            <button id="save-tag-btn">Save</button>
            <button id="cancel-tag-btn">Cancel</button>
          </div>
          
          <!-- ç¼–è¾‘æ ‡ç­¾çš„è¾“å…¥æ¡† -->
          <div class="edit-tag-input hidden" id="edit-tag-input">
            <input type="text" id="edit-tag-text" placeholder="Edit tag name..." maxlength="20">
            <button id="save-edit-btn">Save</button>
            <button id="cancel-edit-btn">Cancel</button>
          </div>
          
          <textarea id="issue-input" rows="3" style="width: 100%; border: 1px solid #ddd; border-radius: 4px; padding: 8px; resize: vertical; margin-top: 8px; font-size: 13px; box-sizing: border-box;" placeholder="Enter issue or note..."></textarea>
          
          <div style="margin-top: 10px;">
            <img id="screenshot-preview" class="screenshot-preview hidden" alt="Screenshot" />
            <div id="no-screenshot" style="text-align: center; padding: 20px; background-color: #f5f5f5; border: 1px dashed #ccc; border-radius: 4px; color: #666; font-size: 12px;">
              ğŸ“· No screenshot taken
            </div>
          </div>
        </div>
        
        <div class="settings-panel">
          <h3>âš™ï¸ Settings</h3>
          
          <!-- Auto-advance setting -->
          <div class="toggle-container">
            <div class="toggle-switch" id="auto-next-toggle">
              <div class="toggle-slider"></div>
            </div>
            <label class="toggle-label">Auto-advance on Pass</label>
          </div>
          
          <!-- Auto-fail on issue setting -->
          <div class="toggle-container">
            <div class="toggle-switch" id="auto-fail-toggle">
              <div class="toggle-slider"></div>
            </div>
            <label class="toggle-label">Auto-fail when Issue added</label>
          </div>
          
          <!-- Preload count setting -->
          <div style="margin: 10px 0;">
            <label for="preload-count" style="display: block; margin-bottom: 5px; font-size: 13px; color: #333;">Preload pages:</label>
            <select id="preload-count" style="width: 100%; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
              <option value="0">Disabled</option>
              <option value="3">3 pages</option>
              <option value="5" selected>5 pages</option>
              <option value="10">10 pages</option>
              <option value="15">15 pages</option>
            </select>
          </div>
          
          <!-- Page jump -->
          <div style="margin: 10px 0;">
            <label for="page-jump" style="display: block; margin-bottom: 5px; font-size: 13px; color: #333;">Jump to page:</label>
            <div style="display: flex; gap: 5px;">
              <input type="number" id="page-jump" min="1" max="1" value="1" style="flex: 1; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" placeholder="Page #">
              <button id="jump-btn" style="padding: 4px 12px; font-size: 12px;">Go</button>
            </div>
          </div>
          
          <div class="preload-status" id="preload-status">
            Preloading: Ready
          </div>
          
          <div class="shortcuts-info">
            <strong>Shortcuts:</strong><br>
            â†‘ Pass (saves as 1)<br>
            â†“ Fail (saves as 0)<br>
            Ctrl+S Save manually
          </div>
          
          <!-- è‡ªå®šä¹‰å¿«æ·é”®é…ç½® -->
          <div style="margin-top: 10px;">
            <button id="toggle-shortcuts-btn" style="background-color: #6c757d; width: 100%;">âŒ¨ï¸ Custom Shortcuts</button>
          </div>
          
          <div class="shortcuts-config" id="shortcuts-config-panel">
            <h4>âŒ¨ï¸ Custom Shortcuts</h4>
            <div id="shortcuts-list">
              <!-- å¿«æ·é”®åˆ—è¡¨å°†ç”±JavaScriptç”Ÿæˆ -->
            </div>
            <div class="shortcuts-actions">
              <button id="reset-shortcuts-btn">Reset All</button>
            </div>
            <div class="shortcut-help">
              Click any shortcut to edit. Press ESC to cancel recording.
            </div>
          </div>
        </div>
        
        <div class="status" id="status">Ready to start</div>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer, shell } = require('electron');
    
    // ç›‘å¬æ¥è‡ªä¸»è¿›ç¨‹çš„å…¨å±€å¿«æ·é”®äº‹ä»¶
    ipcRenderer.on('global-shortcut', (event, action, param) => {
      handleGlobalShortcut(action, param);
    });
    
    // å¤„ç†å…¨å±€å¿«æ·é”®
    function handleGlobalShortcut(action, param) {
      switch (action) {
        case 'pass':
          if (!passBtn.disabled) passBtn.click();
          break;
        case 'fail':
          if (!failBtn.disabled) failBtn.click();
          break;
        case 'save':
          saveBtn.click();
          break;
        case 'reload':
          if (!reloadBtn.disabled) reloadBtn.click();
          break;
        case 'previous':
          if (!prevBtn.disabled) prevBtn.click();
          break;
        case 'next':
          if (!nextBtn.disabled) nextBtn.click();
          break;
        case 'tag':
          // paramæ˜¯æ ‡ç­¾åºå· (1-9)
          if (param && param >= 1 && param <= 9) {
            const targetTag = document.querySelector(`[data-shortcut="${param}"]`);
            if (targetTag) {
              appendIssueTag(targetTag.dataset.tag);
              // è§†è§‰åé¦ˆ
              targetTag.classList.add('active');
              setTimeout(() => targetTag.classList.remove('active'), 200);
            }
          }
          break;
        case 'clear-tags':
          clearIssueInput();
          break;
        default:
          console.log('Unknown global shortcut:', action);
      }
    }
    
    // DOM elements
    const fileBtn = document.getElementById('file-btn');
    const downloadSampleBtn = document.getElementById('download-sample-btn');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const passBtn = document.getElementById('pass-btn');
    const failBtn = document.getElementById('fail-btn');
    const screenshotBtn = document.getElementById('screenshot-btn');
    const saveBtn = document.getElementById('save-btn');
    const reloadBtn = document.getElementById('reload-btn');
    const openExternalBtn = document.getElementById('open-external-btn');
    const webFrame = document.getElementById('web-frame');
    const pageCounterEl = document.getElementById('page-counter');
    const currentQueryEl = document.getElementById('current-query');
    const currentUrlEl = document.getElementById('current-url');
    const currentScoreEl = document.getElementById('current-score');
    const issueInput = document.getElementById('issue-input');
    const screenshotPreview = document.getElementById('screenshot-preview');
    const noScreenshotDiv = document.getElementById('no-screenshot');
    const statusEl = document.getElementById('status');
    const progressFill = document.getElementById('progress-fill');
    const thumbnailPreview = document.getElementById('thumbnail-preview');
    const thumbnailPlaceholder = document.getElementById('thumbnail-placeholder');
    const autoNextToggle = document.getElementById('auto-next-toggle');
    const autoFailToggle = document.getElementById('auto-fail-toggle');
    const preloadStatusEl = document.getElementById('preload-status');
    const preloadCountSelect = document.getElementById('preload-count');
    const pageJumpInput = document.getElementById('page-jump');
    const jumpBtn = document.getElementById('jump-btn');
    const addTagBtn = document.getElementById('add-tag-btn');
    const addTagInput = document.getElementById('add-tag-input');
    const newTagInput = document.getElementById('new-tag-input');
    const saveTagBtn = document.getElementById('save-tag-btn');
    const cancelTagBtn = document.getElementById('cancel-tag-btn');
    const editTagInput = document.getElementById('edit-tag-input');
    const editTagText = document.getElementById('edit-tag-text');
    const saveEditBtn = document.getElementById('save-edit-btn');
    const cancelEditBtn = document.getElementById('cancel-edit-btn');
    const presetTagsContainer = document.getElementById('preset-tags-container');
    const shortcutsList = document.getElementById('shortcuts-list');
    const resetShortcutsBtn = document.getElementById('reset-shortcuts-btn');
    const toggleShortcutsBtn = document.getElementById('toggle-shortcuts-btn');
    const shortcutsConfig = document.querySelector('.shortcuts-config');
    
    // Progress Overview elements
    const progressGrid = document.getElementById('progress-grid');
    const passCountEl = document.getElementById('pass-count');
    const failCountEl = document.getElementById('fail-count');
    const pendingCountEl = document.getElementById('pending-count');
    const totalCountEl = document.getElementById('total-count');
    
    // App state
    let excelData = [];
    let currentIndex = 1; // ä»1å¼€å§‹ï¼Œè·³è¿‡æ ‡é¢˜è¡Œ
    let columns = {};
    let autoNextEnabled = true; // é»˜è®¤å¼€å¯è‡ªåŠ¨è·³è½¬
    let autoFailEnabled = false; // é»˜è®¤å…³é—­è‡ªåŠ¨fail
    let preloadQueue = new Set(); // é¢„åŠ è½½é˜Ÿåˆ—
    let preloadedPages = new Map(); // é¢„åŠ è½½ç¼“å­˜
    let maxPreloadPages = 5; // é»˜è®¤é¢„åŠ è½½5é¡µ
    let customTags = []; // è‡ªå®šä¹‰æ ‡ç­¾æ•°ç»„
    let presetTags = []; // é¢„è®¾æ ‡ç­¾æ•°ç»„ï¼ˆç°åœ¨ä¹Ÿå¯ä»¥ç¼–è¾‘ï¼‰
    let currentEditingTag = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„æ ‡ç­¾
    let customShortcuts = {}; // è‡ªå®šä¹‰å¿«æ·é”®é…ç½®
    let recordingShortcut = null; // å½“å‰æ­£åœ¨å½•åˆ¶çš„å¿«æ·é”®
    let shortcutsVisible = false; // å¿«æ·é”®é…ç½®é¢æ¿å¯è§æ€§
    
    // é»˜è®¤é¢„è®¾æ ‡ç­¾
    const defaultPresetTags = [
      'æœ‰äº‰è®®æ€§',
      'æ¶‰åŠæ•æ„Ÿè¯é¢˜', 
      'è¿‡äºä¸»è§‚è¯„ä»·',
      'è´Ÿé¢è¯­è¨€',
      'è¿‡äºæ ‡é¢˜å…š',
      'æŒ‘æˆ˜æ”¿ç­–/åˆ¶åº¦',
      'å›¾ç‰‡æ— æ³•åŠ è½½'
    ];
    
    // é»˜è®¤å¿«æ·é”®é…ç½®
    const defaultShortcuts = {
      'previous': { keys: ['ArrowLeft'], description: 'Previous Page' },
      'next': { keys: ['ArrowRight'], description: 'Next Page' },
      'pass': { keys: ['ArrowUp'], description: 'Mark as Pass' },
      'fail': { keys: ['ArrowDown'], description: 'Mark as Fail' },
      'save': { keys: ['Control', 's'], description: 'Save Manually' },
      'screenshot': { keys: ['Control', 'p'], description: 'Take Screenshot' },
      'reload': { keys: ['F5'], description: 'Reload Page' },
      'openExternal': { keys: ['Control', 'o'], description: 'Open in Browser' },
      'clearTags': { keys: ['Control', '0'], description: 'Clear Issue Tags' },
      'toggleAutoNext': { keys: ['Control', 'a'], description: 'Toggle Auto-advance' },
      'focusJump': { keys: ['Control', 'g'], description: 'Focus Page Jump' }
    };
    
    // åˆå§‹åŒ–è‡ªå®šä¹‰å¿«æ·é”®ç³»ç»Ÿ
    function initCustomShortcuts() {
      // ä»localStorageåŠ è½½è‡ªå®šä¹‰å¿«æ·é”®
      const savedShortcuts = localStorage.getItem('customShortcuts');
      if (savedShortcuts) {
        try {
          const parsed = JSON.parse(savedShortcuts);
          customShortcuts = { ...defaultShortcuts, ...parsed };
        } catch (e) {
          console.error('Failed to load custom shortcuts:', e);
          customShortcuts = { ...defaultShortcuts };
        }
      } else {
        customShortcuts = { ...defaultShortcuts };
      }
      
      renderShortcutsList();
      updateShortcutsInfo();
    }
    
    // æ¸²æŸ“å¿«æ·é”®åˆ—è¡¨
    function renderShortcutsList() {
      if (!shortcutsList) return;
      
      shortcutsList.innerHTML = '';
      
      Object.entries(customShortcuts).forEach(([action, config]) => {
        const item = document.createElement('div');
        item.className = 'shortcut-item';
        
        const label = document.createElement('div');
        label.className = 'shortcut-label';
        label.textContent = config.description;
        
        const keyDisplay = document.createElement('div');
        keyDisplay.className = 'shortcut-key';
        keyDisplay.textContent = formatShortcutDisplay(config.keys);
        keyDisplay.dataset.action = action;
        keyDisplay.title = 'Click to edit';
        
        keyDisplay.addEventListener('click', () => startRecordingShortcut(action, keyDisplay));
        
        item.appendChild(label);
        item.appendChild(keyDisplay);
        shortcutsList.appendChild(item);
      });
    }
    
    // æ ¼å¼åŒ–å¿«æ·é”®æ˜¾ç¤º
    function formatShortcutDisplay(keys) {
      if (!keys || keys.length === 0) return 'None';
      
      return keys.map(key => {
        switch(key) {
          case 'Control': return 'Ctrl';
          case 'ArrowLeft': return 'â†';
          case 'ArrowRight': return 'â†’';
          case 'ArrowUp': return 'â†‘';
          case 'ArrowDown': return 'â†“';
          case ' ': return 'Space';
          default: return key;
        }
      }).join('+');
    }
    
    // å¼€å§‹å½•åˆ¶å¿«æ·é”®
    function startRecordingShortcut(action, keyElement) {
      if (recordingShortcut) {
        cancelRecordingShortcut();
      }
      
      recordingShortcut = { action, element: keyElement, keys: [] };
      keyElement.classList.add('recording');
      keyElement.textContent = 'Press keys...';
      updateStatus(`Recording shortcut for: ${customShortcuts[action].description}`);
    }
    
    // å–æ¶ˆå½•åˆ¶å¿«æ·é”®
    function cancelRecordingShortcut() {
      if (!recordingShortcut) return;
      
      recordingShortcut.element.classList.remove('recording', 'conflict');
      recordingShortcut.element.textContent = formatShortcutDisplay(customShortcuts[recordingShortcut.action].keys);
      recordingShortcut = null;
      updateStatus('Shortcut recording cancelled');
    }
    
    // ä¿å­˜å½•åˆ¶çš„å¿«æ·é”®
    function saveRecordedShortcut(keys) {
      if (!recordingShortcut || keys.length === 0) return;
      
      const { action, element } = recordingShortcut;
      
      // æ£€æŸ¥å†²çª
      const conflictAction = findShortcutConflict(keys, action);
      if (conflictAction) {
        element.classList.add('conflict');
        element.textContent = `Conflict with: ${customShortcuts[conflictAction].description}`;
        updateStatus(`Shortcut conflicts with: ${customShortcuts[conflictAction].description}`);
        setTimeout(() => {
          element.classList.remove('conflict');
          element.textContent = formatShortcutDisplay(keys);
        }, 2000);
        return;
      }
      
      // ä¿å­˜æ–°å¿«æ·é”®
      customShortcuts[action].keys = [...keys];
      saveCustomShortcuts();
      
      element.classList.remove('recording');
      element.textContent = formatShortcutDisplay(keys);
      recordingShortcut = null;
      
      updateStatus(`Shortcut updated for: ${customShortcuts[action].description}`);
      updateShortcutsInfo();
    }
    
    // æŸ¥æ‰¾å¿«æ·é”®å†²çª
    function findShortcutConflict(keys, excludeAction) {
      const keyString = keys.sort().join('+');
      
      for (const [action, config] of Object.entries(customShortcuts)) {
        if (action === excludeAction) continue;
        if (config.keys.sort().join('+') === keyString) {
          return action;
        }
      }
      
      return null;
    }
    
    // ä¿å­˜è‡ªå®šä¹‰å¿«æ·é”®åˆ°localStorage
    function saveCustomShortcuts() {
      localStorage.setItem('customShortcuts', JSON.stringify(customShortcuts));
    }
    
    // é‡ç½®æ‰€æœ‰å¿«æ·é”®
    function resetAllShortcuts() {
      if (confirm('Reset all shortcuts to default? This cannot be undone.')) {
        customShortcuts = { ...defaultShortcuts };
        saveCustomShortcuts();
        renderShortcutsList();
        updateShortcutsInfo();
        updateStatus('All shortcuts reset to default');
      }
    }
    
    // æ›´æ–°å¿«æ·é”®ä¿¡æ¯æ˜¾ç¤º
    function updateShortcutsInfo() {
      const shortcutsInfo = document.querySelector('.shortcuts-info');
      if (shortcutsInfo) {
        shortcutsInfo.innerHTML = `
          <strong>Current Shortcuts:</strong><br>
          ${formatShortcutDisplay(customShortcuts.pass.keys)} Pass<br>
          ${formatShortcutDisplay(customShortcuts.fail.keys)} Fail<br>
          ${formatShortcutDisplay(customShortcuts.save.keys)} Save<br>
          <em>Click "Custom Shortcuts" below to edit all shortcuts</em>
        `;
      }
    }
    
    // åˆå§‹åŒ–æ ‡ç­¾ç³»ç»Ÿ
    function initTagSystem() {
      // ä»localStorageåŠ è½½é¢„è®¾æ ‡ç­¾
      const savedPresetTags = localStorage.getItem('presetTags');
      if (savedPresetTags) {
        try {
          presetTags = JSON.parse(savedPresetTags);
        } catch (e) {
          console.error('Failed to load preset tags:', e);
          presetTags = [...defaultPresetTags];
        }
      } else {
        presetTags = [...defaultPresetTags];
      }
      
      // ä»localStorageåŠ è½½è‡ªå®šä¹‰æ ‡ç­¾
      const savedCustomTags = localStorage.getItem('customTags');
      if (savedCustomTags) {
        try {
          customTags = JSON.parse(savedCustomTags);
        } catch (e) {
          console.error('Failed to load custom tags:', e);
          customTags = [];
        }
      }
      
      renderAllTags();
    }
    
    // æ¸²æŸ“æ‰€æœ‰æ ‡ç­¾
    function renderAllTags() {
      // æ¸…ç©ºå®¹å™¨ï¼ˆä½†ä¿ç•™Add TagæŒ‰é’®ï¼‰
      const existingTags = presetTagsContainer.querySelectorAll('.preset-tag');
      existingTags.forEach(tag => tag.remove());
      
      // æ¸²æŸ“é¢„è®¾æ ‡ç­¾
      presetTags.forEach((tagText, index) => {
        const tag = createTagElement(tagText, index + 1, 'preset');
        presetTagsContainer.insertBefore(tag, addTagBtn);
      });
      
      // æ¸²æŸ“è‡ªå®šä¹‰æ ‡ç­¾
      customTags.forEach((tagText, index) => {
        const shortcut = presetTags.length + index + 1;
        if (shortcut <= 9) { // åªæœ‰å‰9ä¸ªæ ‡ç­¾æ”¯æŒå¿«æ·é”®
          const tag = createTagElement(tagText, shortcut, 'custom');
          presetTagsContainer.insertBefore(tag, addTagBtn);
        } else {
          const tag = createTagElement(tagText, null, 'custom');
          presetTagsContainer.insertBefore(tag, addTagBtn);
        }
      });
    }
    
    // åˆ›å»ºæ ‡ç­¾å…ƒç´ 
    function createTagElement(tagText, shortcut, type) {
      const tag = document.createElement('span');
      tag.className = type === 'preset' ? 'preset-tag' : 'preset-tag custom-tag';
      tag.textContent = tagText;
      tag.dataset.tag = tagText;
      tag.dataset.type = type;
      
      if (shortcut) {
        tag.dataset.shortcut = shortcut;
        tag.title = `Ctrl+${shortcut} to use${type === 'preset' ? ', double-click to edit' : ', right-click to delete'}`;
      } else {
        tag.title = type === 'preset' ? 'Double-click to edit' : 'Right-click to delete (no shortcut)';
      }
      
      // å·¦é”®ç‚¹å‡»æ·»åŠ æ ‡ç­¾
      tag.addEventListener('click', () => {
        appendIssueTag(tagText);
      });
      
      // åŒå‡»ç¼–è¾‘æ ‡ç­¾
      tag.addEventListener('dblclick', (e) => {
        e.preventDefault();
        startEditingTag(tag, tagText, type);
      });
      
      // å³é”®åˆ é™¤è‡ªå®šä¹‰æ ‡ç­¾
      if (type === 'custom') {
        tag.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          if (confirm(`Delete custom tag "${tagText}"?`)) {
            deleteCustomTag(tagText);
          }
        });
      }
      
      return tag;
    }
    
    // å¼€å§‹ç¼–è¾‘æ ‡ç­¾
    function startEditingTag(tagElement, currentText, type) {
      currentEditingTag = { element: tagElement, text: currentText, type: type };
      editTagText.value = currentText;
      editTagInput.classList.remove('hidden');
      editTagText.focus();
      editTagText.select();
    }
    
    // ä¿å­˜ç¼–è¾‘çš„æ ‡ç­¾
    function saveEditedTag() {
      if (!currentEditingTag) return;
      
      const newText = editTagText.value.trim();
      if (!newText) {
        updateStatus('Tag name cannot be empty');
        return;
      }
      
      if (newText.length > 20) {
        updateStatus('Tag name too long (max 20 characters)');
        return;
      }
      
      const { text: oldText, type } = currentEditingTag;
      
      // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ ‡ç­¾é‡å¤
      const allTags = [...presetTags, ...customTags];
      if (allTags.includes(newText) && newText !== oldText) {
        updateStatus('Tag name already exists');
        return;
      }
      
      if (type === 'preset') {
        const index = presetTags.indexOf(oldText);
        if (index !== -1) {
          presetTags[index] = newText;
          savePresetTags();
          updateStatus(`Preset tag "${oldText}" updated to "${newText}"`);
        }
      } else {
        const index = customTags.indexOf(oldText);
        if (index !== -1) {
          customTags[index] = newText;
          saveCustomTags();
          updateStatus(`Custom tag "${oldText}" updated to "${newText}"`);
        }
      }
      
      renderAllTags();
      cancelEditingTag();
    }
    
    // å–æ¶ˆç¼–è¾‘æ ‡ç­¾
    function cancelEditingTag() {
      currentEditingTag = null;
      editTagText.value = '';
      editTagInput.classList.add('hidden');
    }
    
    // ä¿å­˜é¢„è®¾æ ‡ç­¾åˆ°localStorage
    function savePresetTags() {
      localStorage.setItem('presetTags', JSON.stringify(presetTags));
    }
    
    // åˆå§‹åŒ–è‡ªå®šä¹‰æ ‡ç­¾
    function initCustomTags() {
      // è¿™ä¸ªå‡½æ•°ç°åœ¨ç”±initTagSystem()å¤„ç†
    }
    
    // æ¸²æŸ“è‡ªå®šä¹‰æ ‡ç­¾
    function renderCustomTags() {
      // è¿™ä¸ªå‡½æ•°ç°åœ¨ç”±renderAllTags()å¤„ç†
    }
    
    // ä¿å­˜è‡ªå®šä¹‰æ ‡ç­¾åˆ°localStorage
    function saveCustomTags() {
      localStorage.setItem('customTags', JSON.stringify(customTags));
    }
    
    // æ·»åŠ è‡ªå®šä¹‰æ ‡ç­¾
    function addCustomTag(tagText) {
      if (!tagText || tagText.trim() === '') return;
      
      tagText = tagText.trim();
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const allTags = [...presetTags, ...customTags];
      if (allTags.includes(tagText)) {
        updateStatus('Tag already exists');
        return;
      }
      
      // æ£€æŸ¥é•¿åº¦é™åˆ¶
      if (tagText.length > 20) {
        updateStatus('Tag name too long (max 20 characters)');
        return;
      }
      
      customTags.push(tagText);
      saveCustomTags();
      renderAllTags();
      updateStatus(`Custom tag "${tagText}" added`);
    }
    
    // åˆ é™¤è‡ªå®šä¹‰æ ‡ç­¾
    function deleteCustomTag(tagText) {
      const index = customTags.indexOf(tagText);
      if (index !== -1) {
        customTags.splice(index, 1);
        saveCustomTags();
        renderAllTags();
        updateStatus(`Custom tag "${tagText}" deleted`);
      }
    }
    
    // é¢„åŠ è½½é€»è¾‘
    function startPreloading() {
      // æ¸…ç©ºä¹‹å‰çš„é¢„åŠ è½½
      preloadQueue.clear();
      preloadedPages.clear();
      
      // é¢„åŠ è½½å½“å‰é¡µé¢åçš„é¡µé¢
      preloadNextPages();
    }
    
    function preloadNextPages() {
      if (!excelData || excelData.length <= 1 || maxPreloadPages === 0) {
        updatePreloadStatus('Preloading disabled');
        return;
      }
      
      let preloadCount = 0;
      const dataLength = excelData.length; // åŒ…å«æ ‡é¢˜è¡Œçš„æ€»é•¿åº¦
      const maxDataIndex = dataLength - 1; // æœ€åä¸€è¡Œæ•°æ®çš„ç´¢å¼•
      
      for (let i = currentIndex + 1; i <= Math.min(currentIndex + maxPreloadPages, maxDataIndex); i++) {
        if (!preloadedPages.has(i) && !preloadQueue.has(i)) {
          // æ£€æŸ¥è¿™ä¸€è¡Œæ˜¯å¦æœ‰æœ‰æ•ˆçš„URL
          const rowData = excelData[i];
          const url = rowData && rowData[columns.link];
          if (url && url.trim() && url.startsWith('http')) {
            preloadQueue.add(i);
            preloadCount++;
          }
        }
      }
      
      if (preloadCount > 0) {
        updatePreloadStatus(`Preloading ${preloadCount} pages...`);
        processPreloadQueue();
      } else {
        updatePreloadStatus(`${preloadedPages.size} pages preloaded`);
      }
    }
    
    async function processPreloadQueue() {
      if (preloadQueue.size === 0) return;
      
      const pageIndex = preloadQueue.values().next().value;
      preloadQueue.delete(pageIndex);
      
      try {
        const rowData = excelData[pageIndex];
        const url = rowData && rowData[columns.link];
        
        if (url && url.trim() && url.startsWith('http')) {
          // åœ¨åå°é¢„åŠ è½½URL
          const result = await ipcRenderer.invoke('preload-url', url);
          if (result.success) {
            preloadedPages.set(pageIndex, {
              url: url,
              loaded: true,
              timestamp: Date.now()
            });
            console.log(`Successfully preloaded page ${pageIndex}: ${url}`);
          }
        }
      } catch (error) {
        console.log(`Preload failed for page ${pageIndex}:`, error);
      }
      
      // ç»§ç»­å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ª
      if (preloadQueue.size > 0) {
        setTimeout(() => processPreloadQueue(), 200); // å¢åŠ é—´éš”åˆ°200mså‡å°‘å¡é¡¿
      } else {
        updatePreloadStatus(`${preloadedPages.size} pages preloaded`);
      }
    }
    
    function updatePreloadStatus(message) {
      preloadStatusEl.textContent = message;
    }
    
    // Load specific page
    function loadPage(index) {
      if (!excelData || excelData.length <= 1) return;
      
      // Auto-save previous page when navigating
      if (currentIndex !== index) {
        autoSave();
      }
      
      const maxIndex = excelData.length - 1;
      currentIndex = Math.max(1, Math.min(index, maxIndex)); // ç¡®ä¿ä¸å°äº1ï¼ˆè·³è¿‡æ ‡é¢˜è¡Œï¼‰
      
      // Update page jump input value
      pageJumpInput.value = currentIndex;
      
      // Update navigation buttons
      prevBtn.disabled = currentIndex <= 1; // ç¬¬ä¸€é¡µæ˜¯ç´¢å¼•1
      nextBtn.disabled = currentIndex >= maxIndex;
      
      // Update progress (åŸºäºå®é™…æ•°æ®é¡µæ•°ï¼Œä¸åŒ…æ‹¬æ ‡é¢˜è¡Œ)
      const totalDataPages = maxIndex; // æ€»æ•°æ®é¡µæ•°
      const currentDataPage = currentIndex; // å½“å‰æ•°æ®é¡µ
      const progress = totalDataPages > 0 ? (currentDataPage / totalDataPages) * 100 : 0;
      progressFill.style.width = `${progress}%`;
      
      const rowData = excelData[currentIndex];
      if (!rowData) return;
      
      // Update page counter (æ˜¾ç¤ºç»™ç”¨æˆ·çš„é¡µç ï¼Œä»1å¼€å§‹)
      pageCounterEl.textContent = `${currentIndex}/${maxIndex}`;
      
      // Load query data
      const queryData = rowData[columns.description] || rowData[columns.query] || 'N/A';
      currentQueryEl.textContent = queryData;
      
      // Load URL
      const url = rowData[columns.link];
      if (url) {
        currentUrlEl.textContent = url;
        currentUrlEl.href = url;
      } else {
        currentUrlEl.textContent = 'No URL available';
        currentUrlEl.href = '#';
      }
      
      // Load score data
      const resultData = rowData[columns.result];
      if (resultData === 1) {
        currentScoreEl.textContent = 'âœ… Passed (1)';
        currentScoreEl.style.color = '#388e3c';
        updateContainerStatus(1);
      } else if (resultData === 0) {
        currentScoreEl.textContent = 'âŒ Failed (0)';
        currentScoreEl.style.color = '#d32f2f';
        updateContainerStatus(0);
      } else {
        currentScoreEl.textContent = 'Not scored';
        currentScoreEl.style.color = '#666';
        updateContainerStatus(null);
      }
      
      // Load thumbnail
      const thumbnailUrl = rowData[columns.thumbnail_link];
      if (thumbnailUrl) {
        thumbnailPreview.src = thumbnailUrl;
        thumbnailPreview.classList.remove('hidden');
        thumbnailPlaceholder.style.display = 'none';
        thumbnailPreview.onerror = () => {
          thumbnailPreview.classList.add('hidden');
          thumbnailPlaceholder.style.display = 'block';
        };
      } else {
        thumbnailPreview.classList.add('hidden');
        thumbnailPlaceholder.style.display = 'block';
      }
      
      // Load screenshot data
      const screenshotData = rowData[columns.screenshot];
      if (screenshotData) {
        if (screenshotData.startsWith('screenshots/') || screenshotData.includes('/')) {
          // File path - load from file
          ipcRenderer.invoke('load-screenshot', screenshotData).then(result => {
            if (result.success) {
              const imgSrc = `data:image/png;base64,${result.data}`;
              screenshotPreview.src = imgSrc;
              screenshotPreview.classList.remove('hidden');
              noScreenshotDiv.style.display = 'none';
              screenshotPreview.onclick = () => {
                const newWindow = window.open();
                newWindow.document.write(`<img src="${imgSrc}" style="max-width: 100%; max-height: 100vh; object-fit: contain;">`);
              };
            } else {
              screenshotPreview.classList.add('hidden');
              noScreenshotDiv.style.display = 'flex';
            }
          });
        } else {
          // Legacy base64 without data prefix
          const imgSrc = `data:image/png;base64,${screenshotData}`;
          screenshotPreview.src = imgSrc;
          screenshotPreview.classList.remove('hidden');
          noScreenshotDiv.style.display = 'none';
          screenshotPreview.onclick = () => {
            const newWindow = window.open();
            newWindow.document.write(`<img src="${imgSrc}" style="max-width: 100%; max-height: 100vh; object-fit: contain;">`);
          };
        }
      } else {
        screenshotPreview.classList.add('hidden');
        noScreenshotDiv.style.display = 'flex';
        screenshotPreview.onclick = null;
      }
      
      // Load issue data
      const issueData = rowData[columns.issue] || '';
      issueInput.value = issueData;
      
      // Load URL in webview
      if (url && url.trim() && url.startsWith('http')) {
        // æ£€æŸ¥æ˜¯å¦å·²é¢„åŠ è½½
        if (preloadedPages.has(currentIndex)) {
          updateStatus(`Loading: ${url} (preloaded)`);
          webFrame.innerHTML = '<div style="text-align: center; padding: 20px; color: #4285f4;"><div style="margin-bottom: 10px;">âš¡ Preloaded website loaded instantly</div><div style="font-size: 12px; color: #666;">You can see the actual website content in the embedded browser view</div></div>';
        } else {
          updateStatus(`Loading: ${url}`);
          webFrame.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">ğŸ”„ Loading website...</div>';
        }
        
        // Adjust BrowserView position first
        adjustBrowserViewPosition();
        
        // Use IPC to load URL in BrowserView
        ipcRenderer.invoke('load-url', url).then(result => {
          if (result.success) {
            webFrame.innerHTML = '<div style="text-align: center; padding: 20px; color: #4285f4;"><div style="margin-bottom: 10px;">âœ… Website loaded in the view above</div><div style="font-size: 12px; color: #666;">You can see the actual website content in the embedded browser view</div></div>';
            updateStatus('Website loaded successfully');
          } else {
            webFrame.innerHTML = `
              <div style="text-align: center; padding: 20px; color: #d32f2f;">
                <div style="margin-bottom: 15px;">âš ï¸ Website could not be embedded</div>
                <div style="font-size: 12px; color: #666; margin-bottom: 15px;">
                  This is common with some websites due to security restrictions.<br/>
                  You can still use the "Open in Browser" button below to view it.
                </div>
                <div style="font-size: 11px; color: #999;">Error: ${result.error}</div>
              </div>
            `;
            updateStatus(`Failed to load website: ${result.error}`);
          }
        }).catch(error => {
          webFrame.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #d32f2f;">
              <div style="margin-bottom: 15px;">âŒ Loading Error</div>
              <div style="font-size: 12px; color: #666; margin-bottom: 15px;">
                There was an error loading this website.<br/>
                You can still score it and use "Open in Browser" to view it externally.
              </div>
              <div style="font-size: 11px; color: #999;">Error: ${error.message}</div>
            </div>
          `;
          updateStatus(`Error loading website: ${error.message}`);
        });
      } else {
        webFrame.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">ğŸ“ No valid URL available for this entry</div>';
        updateStatus('No valid URL available');
      }
      
      // è§¦å‘ä¸‹ä¸€æ‰¹é¢„åŠ è½½
      preloadNextPages();
      
      // æ›´æ–°Progress Overview
      updateProgressOverview();
    }
    
    // Event listeners
    prevBtn.addEventListener('click', () => loadPage(currentIndex - 1));
    nextBtn.addEventListener('click', () => loadPage(currentIndex + 1));
    
    // ä¿®æ”¹PassæŒ‰é’®è¡Œä¸ºï¼Œæ”¯æŒè‡ªåŠ¨è·³è½¬
    passBtn.addEventListener('click', () => {
      excelData[currentIndex][columns.result] = 1;
      currentScoreEl.textContent = 'âœ… Passed (1)';
      currentScoreEl.style.color = '#388e3c';
      updateContainerStatus(1);
      updateStatus('Marked as Passed');
      // Auto-save after scoring
      autoSave();
      
      // æ›´æ–°Progress Overview
      updateProgressOverview();
      
      // è‡ªåŠ¨è·³è½¬åˆ°ä¸‹ä¸€é¡µï¼ˆå¦‚æœå¼€å¯äº†è‡ªåŠ¨è·³è½¬ï¼‰
      if (autoNextEnabled && currentIndex < excelData.length - 1) {
        setTimeout(() => {
          loadPage(currentIndex + 1);
        }, 300); // 300mså»¶è¿Ÿè®©ç”¨æˆ·çœ‹åˆ°åé¦ˆ
      }
    });
    
    failBtn.addEventListener('click', () => {
      excelData[currentIndex][columns.result] = 0;
      currentScoreEl.textContent = 'âŒ Failed (0)';
      currentScoreEl.style.color = '#d32f2f';
      updateContainerStatus(0);
      updateStatus('Marked as Failed');
      // Auto-save after scoring
      autoSave();
      
      // æ›´æ–°Progress Overview
      updateProgressOverview();
    });
    
    screenshotBtn.addEventListener('click', async () => {
      try {
        updateStatus('Taking screenshot...');
        const result = await ipcRenderer.invoke('take-screenshot');
        
        if (result.success) {
          // Use base64 for immediate display
          const screenshotData = `data:image/png;base64,${result.screenshot}`;
          screenshotPreview.src = screenshotData;
          screenshotPreview.classList.remove('hidden');
          noScreenshotDiv.style.display = 'none';
          
          // Save file path to Excel (not base64 to avoid character limit)
          excelData[currentIndex][columns.screenshot] = result.filepath;
          
          screenshotPreview.onclick = () => {
            const newWindow = window.open();
            newWindow.document.write(`<img src="${screenshotData}" style="max-width: 100%; max-height: 100vh; object-fit: contain;">`);
          };
          
          updateStatus('Screenshot taken and saved successfully');
          // Auto-save after taking screenshot
          autoSave();
        } else {
          showError('Failed to take screenshot');
        }
      } catch (error) {
        showError(`Screenshot failed: ${error.message}`);
      }
    });
    
    saveBtn.addEventListener('click', async () => {
      try {
        updateStatus('Saving results...');
        await ipcRenderer.invoke('save-excel', excelData);
        updateStatus('âœ… Results manually saved successfully');
      } catch (error) {
        showError(`Save failed: ${error.message}`);
      }
    });
    
    reloadBtn.addEventListener('click', () => loadExcelData());
    
    openExternalBtn.addEventListener('click', () => {
      const url = excelData[currentIndex] && excelData[currentIndex][columns.link];
      if (url) {
        shell.openExternal(url);
        updateStatus('Page opened in external browser');
      }
    });
    
    // Issue input event listener
    let issueInputTimeout;
    issueInput.addEventListener('input', (e) => {
      if (excelData[currentIndex]) {
        excelData[currentIndex][columns.issue] = e.target.value;
        updateStatus('Issue note updated');
        
        // æ£€æŸ¥è‡ªåŠ¨failåŠŸèƒ½
        if (autoFailEnabled) {
          const issueText = e.target.value.trim();
          if (issueText && excelData[currentIndex][columns.result] !== 0) {
            // æœ‰issueå†…å®¹ä¸”å½“å‰ä¸æ˜¯failçŠ¶æ€ï¼Œè‡ªåŠ¨è®¾ä¸ºfail
            excelData[currentIndex][columns.result] = 0;
            currentScoreEl.textContent = 'âŒ Failed (0)';
            currentScoreEl.style.color = '#d32f2f';
            updateContainerStatus(0);
            updateStatus('Auto-failed due to issue content');
            
            // æ›´æ–°Progress Overview
            updateProgressOverview();
          }
        }
        
        // Clear existing timeout
        clearTimeout(issueInputTimeout);
        
        // Auto-save after 1 second of no typing
        issueInputTimeout = setTimeout(() => {
          autoSave();
        }, 1000);
      }
    });
    
    // Auto-save issue on blur
    issueInput.addEventListener('blur', () => {
      updateStatus('Issue note saved');
      // Clear timeout and save immediately on blur
      clearTimeout(issueInputTimeout);
      autoSave();
    });
    
    // Auto-save function
    async function autoSave() {
      if (excelData && excelData.length > 1) {
        try {
          await ipcRenderer.invoke('save-excel', excelData);
          console.log('Auto-saved data successfully');
          // æ˜¾ç¤ºç®€çŸ­çš„è‡ªåŠ¨ä¿å­˜æç¤º
          const originalText = statusEl.textContent;
          const originalBg = statusEl.style.backgroundColor;
          const originalColor = statusEl.style.color;
          
          statusEl.textContent = 'ğŸ’¾ Auto-saved';
          statusEl.style.backgroundColor = '#e8f5e8';
          statusEl.style.color = '#2e7d32';
          
          // 2ç§’åæ¢å¤åŸçŠ¶æ€
          setTimeout(() => {
            statusEl.textContent = originalText;
            statusEl.style.backgroundColor = originalBg;
            statusEl.style.color = originalColor;
          }, 2000);
        } catch (error) {
          console.error('Auto-save failed:', error);
          // ä¸æ˜¾ç¤ºé”™è¯¯ç»™ç”¨æˆ·ï¼Œå› ä¸ºè¿™æ˜¯è‡ªåŠ¨ä¿å­˜
        }
      }
    }
    
    // Initialize
    // loadExcelData(); // æ³¨é‡Šæ‰è‡ªåŠ¨åŠ è½½ï¼Œç°åœ¨ç”±æ–‡ä»¶é€‰æ‹©è§¦å‘
    
    // åˆå§‹åŒ–åº”ç”¨
    function initApp() {
      // åˆå§‹åŒ–å¼€å…³çŠ¶æ€
      autoNextToggle.classList.add('active');
      
      // åˆå§‹åŒ–æ ‡ç­¾åŠŸèƒ½
      initTagSystem();
      
      // åˆå§‹åŒ–è‡ªå®šä¹‰å¿«æ·é”®åŠŸèƒ½
      initCustomShortcuts();
    }
    
    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', initApp);
    
    // æ·»åŠ æ ‡ç­¾æŒ‰é’®äº‹ä»¶
    addTagBtn.addEventListener('click', () => {
      addTagInput.classList.remove('hidden');
      newTagInput.focus();
    });
    
    // ä¿å­˜æ–°æ ‡ç­¾
    saveTagBtn.addEventListener('click', () => {
      const tagText = newTagInput.value.trim();
      if (tagText) {
        addCustomTag(tagText);
        newTagInput.value = '';
        addTagInput.classList.add('hidden');
      }
    });
    
    // å–æ¶ˆæ·»åŠ æ ‡ç­¾
    cancelTagBtn.addEventListener('click', () => {
      newTagInput.value = '';
      addTagInput.classList.add('hidden');
    });
    
    // æ–°æ ‡ç­¾è¾“å…¥æ¡†å›è½¦äº‹ä»¶
    newTagInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        saveTagBtn.click();
      } else if (e.key === 'Escape') {
        cancelTagBtn.click();
      }
    });
    
    // ç¼–è¾‘æ ‡ç­¾äº‹ä»¶ç›‘å¬å™¨
    saveEditBtn.addEventListener('click', saveEditedTag);
    cancelEditBtn.addEventListener('click', cancelEditingTag);
    
    // ç¼–è¾‘æ ‡ç­¾è¾“å…¥æ¡†å›è½¦äº‹ä»¶
    editTagText.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        saveEditedTag();
      } else if (e.key === 'Escape') {
        cancelEditingTag();
      }
    });
    
    // æ ‡ç­¾ç›¸å…³å‡½æ•°
    function appendIssueTag(tagText) {
      const currentValue = issueInput.value.trim();
      if (currentValue) {
        issueInput.value = currentValue + ', ' + tagText;
      } else {
        issueInput.value = tagText;
      }
      
      // æ›´æ–°Excelæ•°æ®
      if (excelData[currentIndex]) {
        excelData[currentIndex][columns.issue] = issueInput.value;
        updateStatus(`Added tag: ${tagText}`);
        
        // æ£€æŸ¥è‡ªåŠ¨failåŠŸèƒ½
        if (autoFailEnabled && issueInput.value.trim() && excelData[currentIndex][columns.result] !== 0) {
          // æœ‰issueå†…å®¹ä¸”å½“å‰ä¸æ˜¯failçŠ¶æ€ï¼Œè‡ªåŠ¨è®¾ä¸ºfail
          excelData[currentIndex][columns.result] = 0;
          currentScoreEl.textContent = 'âŒ Failed (0)';
          currentScoreEl.style.color = '#d32f2f';
          updateContainerStatus(0);
          updateStatus('Auto-failed due to issue tag');
          
          // æ›´æ–°Progress Overview
          updateProgressOverview();
        }
        
        autoSave();
      }
    }
    
    function clearIssueInput() {
      issueInput.value = '';
      if (excelData[currentIndex]) {
        excelData[currentIndex][columns.issue] = '';
        updateStatus('Issue notes cleared');
        autoSave();
      }
    }
    
    // è‡ªåŠ¨è·³è½¬å¼€å…³äº‹ä»¶
    autoNextToggle.addEventListener('click', () => {
      autoNextEnabled = !autoNextEnabled;
      autoNextToggle.classList.toggle('active', autoNextEnabled);
      updateStatus(autoNextEnabled ? 'Auto-advance enabled' : 'Auto-advance disabled');
    });
    
    // è‡ªåŠ¨Failå¼€å…³äº‹ä»¶
    autoFailToggle.addEventListener('click', () => {
      autoFailEnabled = !autoFailEnabled;
      autoFailToggle.classList.toggle('active', autoFailEnabled);
      updateStatus(autoFailEnabled ? 'Auto-fail on issue enabled' : 'Auto-fail on issue disabled');
    });
    
    // é¢„åŠ è½½é¡µæ•°è®¾ç½®äº‹ä»¶
    preloadCountSelect.addEventListener('change', (e) => {
      maxPreloadPages = parseInt(e.target.value);
      updateStatus(`Preload count set to ${maxPreloadPages} pages`);
      
      // é‡æ–°å¼€å§‹é¢„åŠ è½½
      if (excelData && excelData.length > 1) {
        startPreloading();
      }
    });
    
    // é¡µç è·³è½¬äº‹ä»¶
    jumpBtn.addEventListener('click', () => {
      const targetPage = parseInt(pageJumpInput.value);
      const maxPage = excelData ? excelData.length - 1 : 1;
      
      if (targetPage >= 1 && targetPage <= maxPage) {
        loadPage(targetPage);
        updateStatus(`Jumped to page ${targetPage}`);
      } else {
        showError(`Invalid page number. Please enter a number between 1 and ${maxPage}`);
        pageJumpInput.value = currentIndex;
      }
    });
    
    // é¡µç è¾“å…¥æ¡†å›è½¦äº‹ä»¶
    pageJumpInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        jumpBtn.click();
      }
    });
    
    // è‡ªå®šä¹‰å¿«æ·é”®äº‹ä»¶ç›‘å¬å™¨
    resetShortcutsBtn.addEventListener('click', resetAllShortcuts);
    
    toggleShortcutsBtn.addEventListener('click', () => {
      shortcutsVisible = !shortcutsVisible;
      const shortcutsPanel = document.getElementById('shortcuts-config-panel');
      if (shortcutsVisible) {
        shortcutsPanel.style.display = 'block';
        toggleShortcutsBtn.textContent = 'âŒ¨ï¸ Hide Custom Shortcuts';
        toggleShortcutsBtn.style.backgroundColor = '#dc3545';
      } else {
        shortcutsPanel.style.display = 'none';
        toggleShortcutsBtn.textContent = 'âŒ¨ï¸ Custom Shortcuts';
        toggleShortcutsBtn.style.backgroundColor = '#6c757d';
      }
    });
    
    // åˆå§‹åŒ–æ—¶éšè—å¿«æ·é”®é…ç½®åˆ—è¡¨
    window.addEventListener('load', () => {
      const shortcutsPanel = document.getElementById('shortcuts-config-panel');
      if (shortcutsPanel) {
        shortcutsPanel.style.display = 'none'; // é»˜è®¤éšè—
        shortcutsVisible = false; // è®¾ç½®çŠ¶æ€ä¸ºéšè—
        toggleShortcutsBtn.textContent = 'âŒ¨ï¸ Custom Shortcuts'; // æŒ‰é’®æ–‡å­—
        toggleShortcutsBtn.style.backgroundColor = '#6c757d'; // ç°è‰²èƒŒæ™¯
      }
    });
    
    // File selection
    fileBtn.addEventListener('click', async () => {
      try {
        const result = await ipcRenderer.invoke('select-file');
        if (result.success) {
          await loadExcelData();
        }
      } catch (error) {
        showError(`File selection failed: ${error.message}`);
      }
    });
    
    // Download sample Excel file
    downloadSampleBtn.addEventListener('click', async () => {
      try {
        updateStatus('Preparing sample Excel template...');
        const result = await ipcRenderer.invoke('download-sample-excel');
        if (result.success) {
          updateStatus(`âœ… Sample template saved: ${result.fileName}`);
          
          // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯å’ŒæŒ‡å¼•
          const message = `
            ğŸ“¥ æ ·ä¾‹Excelæ¨¡æ¿å·²ä¸‹è½½ï¼
            
            ğŸ”§ ä½¿ç”¨æŒ‡å¼•ï¼š
            1. ç¼–è¾‘Excelæ–‡ä»¶ï¼Œå¡«å…¥æ‚¨çš„ç½‘é¡µæ•°æ®
            2. å¿…å¡«åˆ—ï¼šdescription/queryï¼ˆæè¿°ï¼‰ã€linkï¼ˆç½‘é¡µé“¾æ¥ï¼‰
            3. å¯é€‰åˆ—ï¼šthumbnail_linkï¼ˆç¼©ç•¥å›¾ï¼‰
            4. ç³»ç»Ÿåˆ—ï¼šresultï¼ˆè¯„åˆ†ç»“æœï¼‰ã€issueï¼ˆé—®é¢˜å¤‡æ³¨ï¼‰ã€screenshotï¼ˆæˆªå›¾è·¯å¾„ï¼‰
            
            ğŸ“‚ ä¿å­˜ä½ç½®ï¼š${result.filePath}
          `;
          
          alert(message);
        } else {
          showError(result.error || 'Failed to download sample template');
        }
      } catch (error) {
        showError(`Download failed: ${error.message}`);
      }
    });
    
    // ç¼©ç•¥å›¾ç‚¹å‡»æ”¾å¤§
    thumbnailPreview.addEventListener('click', () => {
      if (thumbnailPreview.src && !thumbnailPreview.classList.contains('hidden')) {
        showFullscreenImage(thumbnailPreview.src);
      }
    });

    // Load Excel data
    async function loadExcelData() {
      try {
        updateStatus('Loading Excel file...');
        const result = await ipcRenderer.invoke('load-excel');
        
        if (result.success) {
          excelData = result.data;
          columns = result.columns;
          currentIndex = 1; // ä»1å¼€å§‹ï¼Œè·³è¿‡æ ‡é¢˜è¡Œ
          
          // æ›´æ–°é¡µç è·³è½¬è¾“å…¥æ¡†çš„æœ€å¤§å€¼
          const maxPage = excelData.length - 1;
          pageJumpInput.max = maxPage;
          pageJumpInput.value = 1;
          
          // Enable controls
          prevBtn.disabled = false;
          nextBtn.disabled = false;
          passBtn.disabled = false;
          failBtn.disabled = false;
          screenshotBtn.disabled = false;
          saveBtn.disabled = false;
          reloadBtn.disabled = false;
          openExternalBtn.disabled = false;
          
          updateStatus(`âœ… Loaded ${maxPage} pages from Excel file`);
          loadPage(1); // åŠ è½½ç¬¬ä¸€é¡µæ•°æ®
          
          // åˆå§‹åŒ–Progress Overview
          initializeProgressOverview();
          
          // å¼€å§‹é¢„åŠ è½½
          startPreloading();
        } else {
          showError(result.error || 'Failed to load Excel file');
        }
      } catch (error) {
        showError(`Failed to load Excel: ${error.message}`);
      }
    }
    
    // ä¿®æ”¹é”®ç›˜å¿«æ·é”®ï¼Œä½¿ç”¨è‡ªå®šä¹‰å¿«æ·é”®ç³»ç»Ÿ
    document.addEventListener('keydown', (e) => {
      // å¦‚æœæ­£åœ¨å½•åˆ¶å¿«æ·é”®ï¼Œè®°å½•æŒ‰é”®
      if (recordingShortcut) {
        e.preventDefault();
        
        // ESCå–æ¶ˆå½•åˆ¶
        if (e.key === 'Escape') {
          cancelRecordingShortcut();
          return;
        }
        
        // æ”¶é›†æŒ‰é”®ç»„åˆ
        const keys = [];
        if (e.ctrlKey) keys.push('Control');
        if (e.altKey) keys.push('Alt');
        if (e.shiftKey) keys.push('Shift');
        if (e.metaKey) keys.push('Meta');
        
        // æ·»åŠ ä¸»é”®ï¼ˆè¿‡æ»¤ä¿®é¥°é”®ï¼‰
        if (!['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
          keys.push(e.key);
        }
        
        if (keys.length > 0) {
          saveRecordedShortcut(keys);
        }
        return;
      }
      
      // å¦‚æœç”¨æˆ·åœ¨è¾“å…¥æ¡†ä¸­ï¼Œåªå“åº”éƒ¨åˆ†å¿«æ·é”®
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        // ä¿å­˜å¿«æ·é”®
        if (isShortcutMatch(e, customShortcuts.save.keys)) {
          e.preventDefault();
          saveBtn.click();
          return;
        }
        
        // Issueæ ‡ç­¾å¿«æ·é”®åœ¨è¾“å…¥æ¡†ä¸­ä¹Ÿè¦å“åº”
        if ((e.ctrlKey || e.metaKey) && !isNaN(e.key)) {
          e.preventDefault();
          const num = parseInt(e.key);
          if (num === 0) {
            clearIssueInput();
          } else if (num >= 1 && num <= 9) {
            const targetTag = document.querySelector(`[data-shortcut="${num}"]`);
            if (targetTag) {
              appendIssueTag(targetTag.dataset.tag);
            }
          }
        }
        return;
      }
      
      // æ£€æŸ¥æ‰€æœ‰è‡ªå®šä¹‰å¿«æ·é”®
      for (const [action, config] of Object.entries(customShortcuts)) {
        if (isShortcutMatch(e, config.keys)) {
          e.preventDefault();
          executeShortcutAction(action);
          return;
        }
      }
      
      // Issueæ ‡ç­¾å¿«æ·é”® (æ‰©å±•åˆ°1-9)
      if ((e.ctrlKey || e.metaKey) && !isNaN(e.key)) {
        e.preventDefault();
        const num = parseInt(e.key);
        if (num === 0) {
          clearIssueInput();
        } else if (num >= 1 && num <= 9) {
          const targetTag = document.querySelector(`[data-shortcut="${num}"]`);
          if (targetTag) {
            appendIssueTag(targetTag.dataset.tag);
            // è§†è§‰åé¦ˆ
            targetTag.classList.add('active');
            setTimeout(() => targetTag.classList.remove('active'), 200);
          }
        }
      }
    });
    
    // æ£€æŸ¥å¿«æ·é”®æ˜¯å¦åŒ¹é…
    function isShortcutMatch(event, shortcutKeys) {
      if (!shortcutKeys || shortcutKeys.length === 0) return false;
      
      const pressedKeys = [];
      if (event.ctrlKey) pressedKeys.push('Control');
      if (event.altKey) pressedKeys.push('Alt');
      if (event.shiftKey) pressedKeys.push('Shift');
      if (event.metaKey) pressedKeys.push('Meta');
      
      // æ·»åŠ ä¸»é”®ï¼ˆè¿‡æ»¤ä¿®é¥°é”®ï¼‰
      if (!['Control', 'Alt', 'Shift', 'Meta'].includes(event.key)) {
        pressedKeys.push(event.key);
      }
      
      // æ¯”è¾ƒæŒ‰é”®ç»„åˆ
      return pressedKeys.sort().join('+') === shortcutKeys.sort().join('+');
    }
    
    // æ‰§è¡Œå¿«æ·é”®åŠ¨ä½œ
    function executeShortcutAction(action) {
      switch (action) {
        case 'previous':
          if (!prevBtn.disabled) loadPage(currentIndex - 1);
          break;
        case 'next':
          if (!nextBtn.disabled) loadPage(currentIndex + 1);
          break;
        case 'pass':
          if (!passBtn.disabled) passBtn.click();
          break;
        case 'fail':
          if (!failBtn.disabled) failBtn.click();
          break;
        case 'save':
          saveBtn.click();
          break;
        case 'screenshot':
          if (!screenshotBtn.disabled) screenshotBtn.click();
          break;
        case 'reload':
          if (!reloadBtn.disabled) reloadBtn.click();
          break;
        case 'openExternal':
          if (!openExternalBtn.disabled) openExternalBtn.click();
          break;
        case 'clearTags':
          clearIssueInput();
          break;
        case 'toggleAutoNext':
          autoNextToggle.click();
          break;
        case 'focusJump':
          pageJumpInput.focus();
          pageJumpInput.select();
          break;
        default:
          console.log('Unknown shortcut action:', action);
      }
    }
    
    // æ·»åŠ çª—å£è°ƒæ•´äº‹ä»¶ç›‘å¬
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        adjustBrowserViewPosition();
      }, 250);
    });
    
    // æ·»åŠ æ»šåŠ¨äº‹ä»¶ç›‘å¬ï¼Œæ»šåŠ¨æ—¶éšè—BrowserView
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      ipcRenderer.invoke('hide-browser-view');
      
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        adjustBrowserViewPosition();
      }, 150);
    });
    
    // BrowserViewä½ç½®è°ƒæ•´å‡½æ•°
    function adjustBrowserViewPosition() {
      const rect = webFrame.getBoundingClientRect();
      ipcRenderer.invoke('adjust-browser-view', {
        x: Math.round(rect.left),
        y: Math.round(rect.top),
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      });
    }
    
    // Utility functions
    function updateStatus(message) {
      statusEl.textContent = message;
      statusEl.style.backgroundColor = '#f2f2f2';
      statusEl.style.color = '#333';
    }
    
    function showError(message) {
      statusEl.textContent = message;
      statusEl.style.backgroundColor = '#ffebee';
      statusEl.style.color = '#c62828';
    }
    
    // æ›´æ–°å®¹å™¨èƒŒæ™¯çŠ¶æ€
    function updateContainerStatus(score) {
      const container = document.querySelector('.container');
      container.classList.remove('status-unscored', 'status-pass', 'status-fail');
      
      if (score === 1) {
        container.classList.add('status-pass');
      } else if (score === 0) {
        container.classList.add('status-fail');
      } else {
        container.classList.add('status-unscored');
      }
    }
    
    // å…¨å±æ˜¾ç¤ºå›¾ç‰‡
    function showFullscreenImage(src) {
      // éšè—BrowserViewä»¥ç¡®ä¿å›¾ç‰‡æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
      ipcRenderer.invoke('hide-browser-view');
      
      // åˆ›å»ºå…¨å±è¦†ç›–å±‚
      const overlay = document.createElement('div');
      overlay.className = 'fullscreen-overlay';
      
      // åˆ›å»ºå…¨å±å›¾ç‰‡
      const img = document.createElement('img');
      img.className = 'fullscreen-image';
      img.src = src;
      
      overlay.appendChild(img);
      document.body.appendChild(overlay);
      
      // å…³é—­å‡½æ•°
      const closeOverlay = () => {
        document.body.removeChild(overlay);
        // æ¢å¤BrowserViewæ˜¾ç¤º
        adjustBrowserViewPosition();
      };
      
      // ç‚¹å‡»å…³é—­
      overlay.addEventListener('click', closeOverlay);
      
      // ESCé”®å…³é—­
      const closeOnEsc = (e) => {
        if (e.key === 'Escape') {
          closeOverlay();
          document.removeEventListener('keydown', closeOnEsc);
        }
      };
      document.addEventListener('keydown', closeOnEsc);
    }
    
    // Progress Overview Functions
    function initializeProgressOverview() {
      if (!excelData || excelData.length <= 1) {
        // æ¸…ç©ºæ˜¾ç¤º
        progressGrid.innerHTML = '';
        updateProgressStats(0, 0, 0, 0);
        return;
      }
      
      const totalPages = excelData.length - 1; // æ’é™¤æ ‡é¢˜è¡Œ
      updateProgressStats(0, 0, totalPages, totalPages);
      createProgressGrid();
      updateProgressOverview();
    }
    
    function createProgressGrid() {
      if (!excelData || excelData.length <= 1) return;
      
      const totalPages = excelData.length - 1; // æ’é™¤æ ‡é¢˜è¡Œ
      progressGrid.innerHTML = '';
      
      for (let i = 1; i <= totalPages; i++) { // ä»1å¼€å§‹ï¼Œè·³è¿‡æ ‡é¢˜è¡Œ
        const item = document.createElement('div');
        item.className = 'progress-item';
        item.dataset.pageIndex = i;
        item.title = `Page ${i}: ${(excelData[i][columns.description] || excelData[i][columns.query] || 'No description').substring(0, 50)}...`;
        
        // ç‚¹å‡»è·³è½¬åˆ°å¯¹åº”é¡µé¢
        item.addEventListener('click', () => {
          loadPage(i);
        });
        
        progressGrid.appendChild(item);
      }
    }
    
    function updateProgressOverview() {
      if (!excelData || excelData.length <= 1) return;
      
      let passCount = 0;
      let failCount = 0;
      let pendingCount = 0;
      const totalPages = excelData.length - 1; // æ’é™¤æ ‡é¢˜è¡Œ
      
      // ç»Ÿè®¡å„çŠ¶æ€çš„é¡µé¢æ•°é‡
      for (let i = 1; i <= totalPages; i++) { // ä»1å¼€å§‹ï¼Œè·³è¿‡æ ‡é¢˜è¡Œ
        const result = excelData[i][columns.result];
        if (result === 1) {
          passCount++;
        } else if (result === 0) {
          failCount++;
        } else {
          pendingCount++;
        }
      }
      
      // æ›´æ–°ç»Ÿè®¡æ•°æ®
      updateProgressStats(passCount, failCount, pendingCount, totalPages);
      
      // æ›´æ–°ç½‘æ ¼æ˜¾ç¤º
      const items = progressGrid.querySelectorAll('.progress-item');
      items.forEach((item, index) => {
        const pageIndex = index + 1; // å¯¹åº”å®é™…çš„é¡µé¢ç´¢å¼•
        const result = excelData[pageIndex][columns.result];
        
        // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
        item.classList.remove('pass', 'fail', 'pending', 'current');
        
        // æ·»åŠ å¯¹åº”çš„çŠ¶æ€ç±»
        if (pageIndex === currentIndex) {
          item.classList.add('current');
        } else if (result === 1) {
          item.classList.add('pass');
        } else if (result === 0) {
          item.classList.add('fail');
        } else {
          item.classList.add('pending');
        }
      });
    }
    
    function updateProgressStats(passCount, failCount, pendingCount, totalCount) {
      passCountEl.textContent = passCount;
      failCountEl.textContent = failCount;
      pendingCountEl.textContent = pendingCount;
      totalCountEl.textContent = totalCount;
    }
  </script>
</body>
</html> 